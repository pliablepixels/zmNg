/**
 * Profile Store
 * 
 * Manages the list of ZoneMinder server profiles and the current active profile.
 * Handles secure storage of passwords and profile switching logic.
 * 
 * Key features:
 * - Persists profiles to localStorage (excluding passwords)
 * - Stores passwords in secure storage (native Keychain/Keystore or encrypted in localStorage)
 * - Handles profile switching with full state cleanup (auth, cache, API client)
 * - Manages app initialization state
 */

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { Profile } from '../api/types';
import { createApiClient, setApiClient } from '../api/client';
import { getServerTimeZone } from '../api/time';
import { fetchZmsPath } from '../api/auth';
import { ProfileService } from '../services/profile';
import { log, LogLevel } from '../lib/logger';
import { useAuthStore } from './auth';

interface ProfileState {
  profiles: Profile[];
  currentProfileId: string | null;
  isInitialized: boolean;
  isBootstrapping: boolean;
  bootstrapStep: 'start' | 'auth' | 'timezone' | 'zms' | 'finalize' | null;

  // Computed
  currentProfile: () => Profile | null;
  profileExists: (name: string, excludeId?: string) => boolean;


  // Actions
  addProfile: (profile: Omit<Profile, 'id' | 'createdAt'>) => Promise<string>;
  updateProfile: (id: string, updates: Partial<Profile>) => Promise<void>;
  deleteProfile: (id: string) => Promise<void>;
  deleteAllProfiles: () => Promise<void>;
  switchProfile: (id: string) => Promise<void>;
  setDefaultProfile: (id: string) => void;
  reLogin: () => Promise<boolean>;

  // Helpers
  getDecryptedPassword: (profileId: string) => Promise<string | undefined>;
}

let storeSet: ((partial: Partial<ProfileState>) => void) | null = null;
let storeGet: (() => ProfileState) | null = null;

export const useProfileStore = create<ProfileState>()(
  persist(
    (set, get) => {
      storeSet = set;
      storeGet = get;
      return {
        profiles: [],
        currentProfileId: null,
        isInitialized: false,
        isBootstrapping: false,
        bootstrapStep: null,

        /**
         * Get the currently active profile object.
         */
        currentProfile: () => {
          const { profiles, currentProfileId } = get();
          return profiles.find((p) => p.id === currentProfileId) || null;
        },

        /**
         * Check if a profile with the given name already exists.
         * Case-insensitive.
         */
        profileExists: (name, excludeId) => {
          const { profiles } = get();
          return profiles.some(
            (p) => p.name.toLowerCase() === name.toLowerCase() && p.id !== excludeId
          );
        },

        /**
         * Add a new profile.
         * 
         * Generates a UUID, encrypts the password (if provided), and adds to the list.
         * If it's the first profile, it becomes the default and current profile.
         */
        addProfile: async (profileData) => {
          // Check for duplicate names
          if (!ProfileService.validateNameAvailability(profileData.name, get().profiles)) {
            throw new Error(`Profile "${profileData.name}" already exists`);
          }

          const newProfileId = crypto.randomUUID();

          // Store password in secure storage (native keystore on mobile, encrypted on web)
          if (profileData.password) {
            await ProfileService.savePassword(newProfileId, profileData.password);
          }

          // Don't store password in Zustand state - it's in secure storage
          const newProfile: Profile = {
            ...profileData,
            password: profileData.password ? 'stored-securely' : undefined, // Flag indicating password exists
            id: newProfileId,
            createdAt: Date.now(),
          };

          set((state) => {
            // If this is the first profile, make it default
            const isFirst = state.profiles.length === 0;
            const profiles = [...state.profiles, newProfile];

            return {
              profiles,
              currentProfileId: isFirst ? newProfile.id : state.currentProfileId,
            };
          });

          // If this is now the current profile, initialize API client
          if (get().currentProfileId === newProfile.id) {
            setApiClient(createApiClient(newProfile.apiUrl));

            // Fetch timezone for new profile
            try {
              // Get token from auth store state
              const { useAuthStore } = await import('./auth');
              const { accessToken } = useAuthStore.getState();
              const timezone = await getServerTimeZone(accessToken || undefined);
              get().updateProfile(newProfile.id, { timezone });
            } catch (e) {
              log.profileService('Failed to fetch timezone for new profile', LogLevel.WARN, { error: e });
            }
          }

          return newProfileId;
        },

        /**
         * Update an existing profile.
         * 
         * Handles password updates by re-encrypting and storing in secure storage.
         * Re-initializes API client if the current profile's URL changes.
         */
        updateProfile: async (id, updates) => {
          log.profileService(`updateProfile called for profile ID: ${id}`, LogLevel.INFO, updates);

          // Check for duplicate names if name is being updated
          if (updates.name && !ProfileService.validateNameAvailability(updates.name, get().profiles, id)) {
            throw new Error(`Profile "${updates.name}" already exists`);
          }

          // Store password in secure storage if provided
          let processedUpdates = { ...updates };
          if (updates.password) {
            await ProfileService.savePassword(id, updates.password);
            // Set flag instead of actual password
            processedUpdates.password = 'stored-securely';
          }

          set((state) => ({
            profiles: state.profiles.map((p) => (p.id === id ? { ...p, ...processedUpdates } : p)),
          }));

          // If updating current profile's API URL, reinitialize client
          const currentProfile = get().currentProfile();
          if (currentProfile?.id === id && updates.apiUrl) {
            setApiClient(createApiClient(updates.apiUrl, get().reLogin));
          }

          log.profileService('updateProfile complete', LogLevel.INFO);
        },

        /**
         * Delete a profile.
         * 
         * Removes the profile from the list and deletes its password from secure storage.
         * If the current profile is deleted, switches to another available profile or null.
         */
        deleteProfile: async (id) => {
          // Remove password from secure storage
          await ProfileService.deletePassword(id);

          set((state) => {
            const profiles = state.profiles.filter((p) => p.id !== id);
            const currentProfileId =
              state.currentProfileId === id
                ? profiles.length > 0
                  ? profiles[0].id
                  : null
                : state.currentProfileId;

            return { profiles, currentProfileId };
          });

          // Reinitialize API client if current profile changed
          const newCurrentProfile = get().currentProfile();
          if (newCurrentProfile) {
            setApiClient(createApiClient(newCurrentProfile.apiUrl, get().reLogin));
          }
        },

        /**
         * Delete all profiles.
         * 
         * Clears all profiles and removes all passwords from secure storage.
         * Resets the API client.
         */
        deleteAllProfiles: async () => {
          const { profiles } = get();

          // Remove all passwords from secure storage
          for (const profile of profiles) {
            await ProfileService.deletePassword(profile.id);
          }

          // Clear all profiles and reset state
          set({ profiles: [], currentProfileId: null });

          // Reset API client
          const { resetApiClient } = await import('../api/client');
          resetApiClient();

          log.profileService('All profiles deleted', LogLevel.INFO);
        },

        /**
         * Switch to a different profile.
         * 
         * Performs a full context switch:
         * 1. Clears auth state (logout)
         * 2. Clears query cache (React Query)
         * 3. Resets API client
         * 4. Sets new profile as current
         * 5. Initializes API client with new URL
         * 6. Attempts to authenticate with stored credentials
         * 
         * Includes rollback logic if switching fails.
         */
        switchProfile: async (id) => {
          const profile = get().profiles.find((p) => p.id === id);
          if (!profile) {
            throw new Error(`Profile ${id} not found`);
          }

          // Save previous profile for rollback
          const previousProfileId = get().currentProfileId;
          const previousProfile = previousProfileId
            ? get().profiles.find((p) => p.id === previousProfileId)
            : null;

          log.profileService('Starting profile switch', LogLevel.INFO, {
            from: previousProfile?.name || 'None',
            to: profile.name,
            targetPortal: profile.portalUrl,
            targetAPI: profile.apiUrl,
          });

          try {
            // STEP 1: Clear ALL existing state FIRST (critical for avoiding data mixing)
            log.profileService('Step 1: Clearing all existing state', LogLevel.INFO);

            const { useAuthStore } = await import('./auth');
            log.profileService('Clearing auth state (logout)', LogLevel.INFO);
            useAuthStore.getState().logout();

            const { clearQueryCache } = await import('./query-cache');
            log.profileService('Clearing query cache', LogLevel.INFO);
            clearQueryCache();

            const { resetApiClient } = await import('../api/client');
            log.profileService('Resetting API client', LogLevel.INFO);
            resetApiClient();

            // STEP 2: Update current profile ID
            log.profileService('Step 2: Setting new profile as current', LogLevel.INFO);
            set({ currentProfileId: id });

            // Update last used timestamp (don't await this)
            get().updateProfile(id, { lastUsed: Date.now() });

            // STEP 3: Initialize API client with new profile
            log.profileService('Step 3: Initializing API client', LogLevel.INFO, { apiUrl: profile.apiUrl });
            setApiClient(createApiClient(profile.apiUrl, get().reLogin));
            log.profileService('API client initialized', LogLevel.INFO);

            // STEP 4: Authenticate immediately if credentials exist
            if (profile.username && profile.password) {
              log.profileService('Step 4: Authenticating with stored credentials', LogLevel.INFO, {
                username: profile.username,
              });

              try {
                // Decrypt password before login
                const decryptedPassword = await get().getDecryptedPassword(id);
                if (!decryptedPassword) {
                  throw new Error('Failed to decrypt password');
                }

                // Use the auth store action so state is updated!
                const { useAuthStore } = await import('./auth');
                await useAuthStore.getState().login(profile.username, decryptedPassword);
                log.profileService('Authentication successful', LogLevel.INFO);
              } catch (authError: unknown) {
                log.profileService('Authentication failed - this might be OK if server does not require auth', LogLevel.WARN, { error: authError, });
                // Don't throw - allow switch to complete even if auth fails
                // Some servers (like demo.zoneminder.com) work without auth
              }
              log.profileService('No credentials stored, skipping authentication', LogLevel.INFO);
              log.profileService('This is normal for public servers', LogLevel.INFO);
            }

            // STEP 5: Fetch Server Timezone
            try {
              log.profileService('Step 5: Fetching server timezone', LogLevel.INFO);
              // Explicitly pass token if we have one to ensure it's used
              const { useAuthStore } = await import('./auth');
              const { accessToken } = useAuthStore.getState();
              const timezone = await getServerTimeZone(accessToken || undefined);
              log.profileService('Server timezone fetched', LogLevel.INFO, { timezone });
              get().updateProfile(id, { timezone });
            } catch (tzError) {
              log.profileService('Failed to fetch server timezone', LogLevel.WARN, { error: tzError });
              // Don't fail the switch for this
            }

            // STEP 5.5: Fetch ZMS path and update CGI URL if different from inferred
            try {
              log.profileService('Step 5.5: Fetching ZMS path from server config', LogLevel.INFO);
              const zmsPath = await fetchZmsPath();
              if (zmsPath && profile.portalUrl) {
                // Construct the full CGI URL from portal + ZMS path
                try {
                  const url = new URL(profile.portalUrl);
                  const newCgiUrl = `${url.origin}${zmsPath}`;

                  // Only update if different from current
                  if (newCgiUrl !== profile.cgiUrl) {
                    log.profileService('ZMS path fetched, updating CGI URL', LogLevel.INFO, {
                      oldCgiUrl: profile.cgiUrl,
                      zmsPath,
                      newCgiUrl
                    });
                    get().updateProfile(id, { cgiUrl: newCgiUrl });
                  } else {
                    log.profileService('ZMS path matches current CGI URL, no update needed', LogLevel.INFO, { cgiUrl: profile.cgiUrl });
                  }
                } catch (urlError) {
                  log.profileService('Failed to construct CGI URL from ZMS path', LogLevel.WARN, {
                    portalUrl: profile.portalUrl,
                    zmsPath,
                    error: urlError
                  });
                }
              } else {
                log.profileService('ZMS path not available, keeping current CGI URL', LogLevel.INFO, { cgiUrl: profile.cgiUrl });
              }
            } catch (zmsError) {
              log.profileService('Failed to fetch ZMS path during profile switch', LogLevel.WARN, { error: zmsError });
              // Don't fail the switch for this
            }

            log.profileService('Profile switch completed successfully', LogLevel.INFO, { currentProfile: profile.name });

          } catch (error) {
            log.profileService('Profile switch FAILED', LogLevel.ERROR, error);

            // ROLLBACK: Restore previous profile if it exists
            if (previousProfile) {
              log.profileService('Starting rollback to previous profile', LogLevel.INFO, {
                previousProfile: previousProfile.name,
              });

              try {
                // Clear state again to ensure clean rollback
                const { useAuthStore } = await import('./auth');
                useAuthStore.getState().logout();

                const { clearQueryCache } = await import('./query-cache');
                clearQueryCache();

                const { resetApiClient } = await import('../api/client');
                resetApiClient();

                // Restore previous profile
                log.profileService('Restoring previous profile ID', LogLevel.INFO);
                set({ currentProfileId: previousProfileId });

                // Re-initialize with previous profile
                log.profileService('Re-initializing API client', LogLevel.INFO, { apiUrl: previousProfile.apiUrl });
                setApiClient(createApiClient(previousProfile.apiUrl, get().reLogin));

                // Try to re-authenticate with previous profile
                if (previousProfile.username && previousProfile.password) {
                  log.profileService('Re-authenticating with previous profile', LogLevel.INFO);
                  const decryptedPassword = await get().getDecryptedPassword(previousProfileId!);
                  if (decryptedPassword) {
                    const { useAuthStore } = await import('./auth');
                    await useAuthStore
                      .getState()
                      .login(previousProfile.username, decryptedPassword);
                    log.profileService('Rollback successful', LogLevel.INFO, { restoredTo: previousProfile.name });
                  }
                } else {
                  log.profileService('Rollback successful (no auth)', LogLevel.INFO);
                }
              } catch (rollbackError) {
                log.profileService('Rollback FAILED - user may need to manually re-authenticate', LogLevel.ERROR, { rollbackError });
              }
            }

            // Re-throw the original error
            throw error;
          }
        }, setDefaultProfile: (id) => {
          set((state) => ({
            profiles: state.profiles.map((p) => ({
              ...p,
              isDefault: p.id === id,
            })),
          }));
        },

        reLogin: async () => {
          const { currentProfileId, getDecryptedPassword, profiles } = get();
          if (!currentProfileId) return false;

          const profile = profiles.find((p) => p.id === currentProfileId);
          if (!profile || !profile.username || !profile.password) return false;

          try {
            const password = await getDecryptedPassword(currentProfileId);
            if (!password) return false;

            const { useAuthStore } = await import('./auth');
            await useAuthStore.getState().login(profile.username, password);
            return true;
          } catch (e) {
            log.profileService('Re-login helper failed', LogLevel.ERROR, { error: e });
            return false;
          }
        },

        /**
         * Retrieve decrypted password for a profile.
         * 
         * Fetches the encrypted password from secure storage and decrypts it.
         */
        getDecryptedPassword: async (profileId) => {
          const profile = get().profiles.find((p) => p.id === profileId);
          if (!profile?.password || profile.password !== 'stored-securely') {
            return undefined;
          }

          return ProfileService.getPassword(profileId);
        },
      };
    },
    {
      name: 'zmng-profiles',
      // On load, initialize API client with current profile and authenticate
      onRehydrateStorage: () => {
        try {
          log.profileService('onRehydrateStorage: Zustand persist starting rehydration', LogLevel.INFO);
        } catch {
          // Logger might not be initialized in test environment
        }

        return async (state) => {
          try {
            const bootstrapStart = Date.now();
            const BOOTSTRAP_STEP_TIMEOUT_MS = 8000;
            const BOOTSTRAP_TOTAL_TIMEOUT_MS = 20000;
            const getState = () => {
              if (!storeGet) {
                throw new Error('Profile store not ready');
              }
              return storeGet();
            };
            const setState = (partial: Partial<ProfileState>) => {
              if (storeSet) {
                storeSet(partial);
              }
            };
            const withTimeout = async <T>(
              label: string,
              promise: Promise<T>,
              timeoutMs = BOOTSTRAP_STEP_TIMEOUT_MS
            ) => {
              let timeoutId: ReturnType<typeof setTimeout> | undefined;
              const timeoutPromise = new Promise<never>((_, reject) => {
                timeoutId = setTimeout(() => {
                  reject(new Error(`${label} timed out after ${timeoutMs}ms`));
                }, timeoutMs);
              });

              try {
                return await Promise.race([promise, timeoutPromise]);
              } finally {
                if (timeoutId) {
                  clearTimeout(timeoutId);
                }
              }
            };
            const logDuration = (message: string, startTime: number, context: Record<string, unknown> = {}) => {
              log.profileService(message, LogLevel.INFO, {
                ...context,
                durationMs: Date.now() - startTime,
              });
            };

            const setInitializationState = (bootstrapping: boolean) => {
              setState({
                isBootstrapping: bootstrapping,
                isInitialized: true,
                bootstrapStep: bootstrapping ? 'start' : null,
              });
            };

            try {
              log.profileService('onRehydrateStorage called', LogLevel.INFO, { hasState: !!state, currentProfileId: state?.currentProfileId });
            } catch {
              // Logger might not be initialized in test environment
            }

            if (!state?.currentProfileId) {
              try {
                log.profileService('No current profile found on app load', LogLevel.INFO, { state });
              } catch {
                // Logger might not be initialized in test environment
              }
              setInitializationState(false);
              try {
                log.profileService('isInitialized set to true (no profile)', LogLevel.INFO);
              } catch {
                // Logger might not be initialized in test environment
              }
              return;
            }

            const profile = state.profiles.find((p) => p.id === state.currentProfileId);
            if (!profile) {
              try {
                log.profileService('Current profile ID exists but profile not found', LogLevel.ERROR, { profileId: state.currentProfileId, });
              } catch {
                // Logger might not be initialized in test environment
              }
              // CRITICAL: Set isInitialized even on error to prevent hanging
              setInitializationState(false);
              return;
            }

            try {
              log.profileService('App loading with profile', LogLevel.INFO, {
                name: profile.name,
                id: profile.id,
                portalUrl: profile.portalUrl,
                apiUrl: profile.apiUrl,
                cgiUrl: profile.cgiUrl,
                username: profile.username || '(not set)',
                hasPassword: !!profile.password,
                passwordLength: profile.password?.length,
                isDefault: profile.isDefault,
                createdAt: new Date(profile.createdAt).toLocaleString(),
                lastUsed: profile.lastUsed ? new Date(profile.lastUsed).toLocaleString() : 'never',
              });
            } catch {
              // Logger might not be initialized in test environment
            }

            try {
              const clearStart = Date.now();
              try {
                log.profileService('Clearing stale auth and cache', LogLevel.INFO);
              } catch {
                // Logger might not be initialized in test environment
              }
              const { useAuthStore } = await import('./auth');
              useAuthStore.getState().logout();

              const { clearQueryCache } = await import('./query-cache');
              clearQueryCache();
              logDuration('Bootstrap step: cleared auth and cache', clearStart);

              const apiClientStart = Date.now();
              try {
                log.profileService('Initializing API client', LogLevel.INFO, { apiUrl: profile.apiUrl });
              } catch {
                // Logger might not be initialized in test environment
              }
              setApiClient(createApiClient(profile.apiUrl, getState().reLogin));
              logDuration('Bootstrap step: API client ready', apiClientStart, { apiUrl: profile.apiUrl });
            } catch (error) {
              log.profileService('Profile bootstrap failed during early initialization', LogLevel.ERROR, error);
              setInitializationState(false);
              return;
            }

            setInitializationState(true);

            let overallTimeoutId: ReturnType<typeof setTimeout> | undefined;
            overallTimeoutId = setTimeout(() => {
              if (getState().isBootstrapping) {
                log.profileService('Profile bootstrap exceeded timeout; allowing UI to continue', LogLevel.WARN, { timeoutMs: BOOTSTRAP_TOTAL_TIMEOUT_MS, });
                setState({ isBootstrapping: false, bootstrapStep: null });
              }
            }, BOOTSTRAP_TOTAL_TIMEOUT_MS);

            const runBootstrapTasks = async () => {
              try {
                if (profile.username && profile.password) {
                  setState({ bootstrapStep: 'auth' });
                  const authStart = Date.now();
                  try {
                    log.profileService('Authenticating with stored credentials', LogLevel.INFO, { username: profile.username });
                  } catch {
                    // Logger might not be initialized in test environment
                  }
                  try {
                    const decryptedPassword = await withTimeout(
                      'Password decrypt',
                      getState().getDecryptedPassword(profile.id)
                    );
                    if (!decryptedPassword) {
                      throw new Error('Failed to decrypt password');
                    }

                    const { useAuthStore } = await import('./auth');
                    await withTimeout(
                      'Authentication',
                      useAuthStore.getState().login(profile.username, decryptedPassword)
                    );
                    logDuration('Bootstrap step: authentication complete', authStart, { username: profile.username });
                  } catch (error) {
                    log.profileService('Authentication failed on app load - this might be OK if server does not require auth', LogLevel.WARN, { error, });
                    logDuration('Bootstrap step: authentication failed', authStart);
                  }
                } else {
                  log.profileService('No credentials stored, skipping authentication', LogLevel.INFO);
                  log.profileService('This is normal for public servers', LogLevel.INFO);
                }

                setState({ bootstrapStep: 'timezone' });
                const timezoneStart = Date.now();
                try {
                  log.profileService('Fetching server timezone on load', LogLevel.INFO);
                  const { useAuthStore } = await import('./auth');
                  const { accessToken } = useAuthStore.getState();
                  const timezone = await withTimeout(
                    'Timezone fetch',
                    getServerTimeZone(accessToken || undefined)
                  );
                  if (timezone !== profile.timezone) {
                    getState().updateProfile(profile.id, { timezone });
                  }
                  logDuration('Bootstrap step: timezone fetched', timezoneStart, { timezone });
                } catch (tzError) {
                  log.profileService('Failed to fetch timezone on load', LogLevel.WARN, { error: tzError });
                  logDuration('Bootstrap step: timezone fetch failed', timezoneStart);
                }

                setState({ bootstrapStep: 'zms' });
                const zmsStart = Date.now();
                try {
                  log.profileService('Fetching ZMS path from server config', LogLevel.INFO);
                  const zmsPath = await withTimeout('ZMS path fetch', fetchZmsPath());
                  if (zmsPath && profile.portalUrl) {
                    try {
                      const url = new URL(profile.portalUrl);
                      const newCgiUrl = `${url.origin}${zmsPath}`;

                      if (newCgiUrl !== profile.cgiUrl) {
                        log.profileService('ZMS path fetched, updating CGI URL', LogLevel.INFO, {
                          oldCgiUrl: profile.cgiUrl,
                          zmsPath,
                          newCgiUrl
                        });
                        getState().updateProfile(profile.id, { cgiUrl: newCgiUrl });
                      } else {
                        log.profileService('ZMS path matches current CGI URL, no update needed', LogLevel.INFO, { cgiUrl: profile.cgiUrl });
                      }
                    } catch (urlError) {
                      log.profileService('Failed to construct CGI URL from ZMS path', LogLevel.WARN, {
                        portalUrl: profile.portalUrl,
                        zmsPath,
                        error: urlError
                      });
                    }
                  } else {
                    log.profileService('ZMS path not available, keeping current CGI URL', LogLevel.INFO, { cgiUrl: profile.cgiUrl });
                  }
                  logDuration('Bootstrap step: ZMS path fetched', zmsStart);
                } catch (zmsError) {
                  log.profileService('Failed to fetch ZMS path on load', LogLevel.WARN, { error: zmsError });
                  logDuration('Bootstrap step: ZMS path fetch failed', zmsStart);
                }
                setState({ bootstrapStep: 'finalize' });
              } finally {
                logDuration('Profile bootstrap completed', bootstrapStart, {
                  profileId: profile.id,
                });
                if (overallTimeoutId) {
                  clearTimeout(overallTimeoutId);
                }
                setState({ isBootstrapping: false, bootstrapStep: null });
              }
            };

            void runBootstrapTasks();
          } catch (error) {
            // CRITICAL: Catch any unexpected errors in onRehydrateStorage to prevent app from hanging
            log.profileService(
              'CRITICAL: Unexpected error in onRehydrateStorage - forcing initialization',
              LogLevel.ERROR,
              { error }
            );
            // Force initialization to prevent hanging
            if (storeSet) {
              storeSet({ isInitialized: true, isBootstrapping: false, bootstrapStep: null });
            }
          }
        };
      },
    }
  )
);

// Subscribe to auth store to update refresh token in profile
useAuthStore.subscribe((state) => {
  const { refreshToken } = state;
  const { currentProfileId, updateProfile, currentProfile } = useProfileStore.getState();

  if (currentProfileId && refreshToken) {
    const profile = currentProfile();
    if (profile && profile.refreshToken !== refreshToken) {
      log.profileService('Updating profile with new refresh token', LogLevel.INFO, { profileId: currentProfileId });
      updateProfile(currentProfileId, { refreshToken });
    }
  }
});
